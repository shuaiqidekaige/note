## 变量绑定

在rust中，变量赋值，被称作变量绑定，即`let a = "hello world"`（因为rust的所有权，每个内存对象都有一个主人，而把赋值这个动作，称为绑定主人）。

变量在使用前必须初始化（即绑定值），如果没被使用，可以不需要初始化。

## 变量可变性

rust中，变量是不可变的。如果需要改变变量，则需要通过 `mut` 关键字，让变量变为可变，即`let mut a = "hello world"`。

rust之所以设计变量不可变，是为了避免预期错误发生在变量中。同时引入mut，会让人一看到mut，就知道这个变量是可变的。（选择可变还是不可变，更多的还是取决于你的使用场景，例如不可变可以带来安全性，但是丧失了灵活性和性能。而可变变量最大的好处就是使用上的灵活性和性能上的提升。）

## 忽略未使用变量

比较少的一种情况，例如你写了一个无用的变量，在rust中，会给你一个警告。通过下划线作为变量名开头，可以忽略警告，即：
``` rust
fn main () {
   let _x = 5;
}
```

## 变量解构

如同javascript中的解构一样，rust也存在解构的特性，即：
``` Rust
fn main () {
  let (a, mut b):(bool, bool) = (true, false);
  let (a, b, c, d, e); (a, b) = (1, 2); 
  // _ 代表匹配一个值，但是我们不关心具体的值是什么，因此没有使用一个变量名而是使用了 _ 
  [c, .., d, _] = [1, 2, 3, 4, 5]; 
  Struct { e, .. } = Struct { e: 5 };
}
```


## 变量遮蔽

rust中，变量遮蔽的意思其实就是声明相同的变量名，在后面声明的变量会盖住前面声明的。
``` Rust
fn main () {
  let x = 1;
  let x = x + 1;
  {
    let x = x * 2;
  }
}
```

### 与mut的区别

变量遮蔽生成的是不同的新变量，只是两个变量拥有相同名字，涉及内存对象分配。而mut申明的变量，是修改同一内存上的地址的值，并不会发生内存对象的再分配，所以性能会更好。




## 变量和常量的区别

-   常量不允许使用 `mut`。**常量不仅仅默认不可变，而且自始至终不可变**，因为常量在编译完成后，已经确定它的值。
-   常量使用 `const` 关键字而不是 `let` 关键字来声明，并且值的类型**必须**标注。
-   常量的值一开始就需要初始化好（绑定所有权）


